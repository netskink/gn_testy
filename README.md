# gn_testy

Experiments with gn (generate ninja)

### Credits
Some of this contact is directly lifted from original sources, but ideally its a rewrite of notes.  See the following URLS

* [quickstart](https://gn.googlesource.com/gn/+/main/docs/quick_start.md)
* [Using GN build presentation](https://www.google.com/url?sa=t&source=web&rct=j&opi=89978449&url=https://docs.google.com/presentation/d/15Zwb53JcncHfEwHpnG_PoIbbzQ3GQi_cpujYwbpcbZo/htmlpresent&ved=2ahUKEwiew7Xw9rCGAxWtF2IAHZxWBxs4ChAWegQIChAB&usg=AOvVaw2juFw165sTXsAIj_l_fJ0a)
* [gn cookbook](https://chromium.googlesource.com/chromium/src/tools/gn/+/48062805e19b4697c5fbd926dc649c78b6aaa138/docs/cookbook.md)
* [chrome cookbook](https://www.chromium.org/chromium-os/developer-library/guides/documentation/chromium-cookbook/)


## Notes

* mailing list
	- gn-dev@chromium.org
* [git](https://gn.googlesource.com)
* [consolidated help](./gn/docs/reference.md)
	- above link assumes you have git cloned gn in this repo

### gn and ninja files

gn will generate the initial ninja files.

Assuming the current directory has the following files:

* .gn
* BUILD.gn

This command sequence:

```
$ gn gen -C out
```

Will make an out dir.  In this dir will be the following files:

* args.gn
* build.ninja
* build.ninja.d
* build.ninja.stamp
* toolchain.ninja
* obj/ dir

For example three (mine3) obj/ dir will contain the following files:

* main.ninja
	- the exe 
* mymath.ninja
	- the static library (*.a)
* mystring.ninja
	- the dynamic/shared libray (*.so)

### gn and regenerating ninja files

Once you have run the `gn gen` command you do not need
to rerun `gn` explicitly even if you have modified the `BUILD.gn`
file.

The ninja files generated by ninja will automatically rerun ninja.  Here
is an example:

Generate the ninja files.

```
$ gn gen -C out
Done. Made 3 targets from 4 files in 7ms
```

Build the code using ninja

```
$ ninja -v -C out
ninja: Entering directory `out'
[1/6] g++ -MMD -MF obj/src/main.main.o.d     -c ../src/main.cc -o obj/src/main.main.o
[2/6] g++ -MMD -MF obj/src/libmymath.MyMath.o.d     -c ../src/MyMath.cc -o obj/src/libmymath.MyMath.o
[3/6] g++ -MMD -MF obj/src/libmystring.MyString.o.d -DMYSTRING_IMPLEMENTATION    -c ../src/MyString.cc -o obj/src/libmystring.MyString.o
[4/6] ar rcs obj/libmymath.a obj/src/libmymath.MyMath.o
[5/6] g++ -shared  -o ./libmystring.so -install_name @executable_path/./libmystring.so @libmystring.so.rsp
[6/6] g++  -o main @main.rsp  
```

Touch the original `BUILD.gn` file, rerun `ninja` and see how it reruns `gn.`

```
$ touch BUILD.gn 
$ ninja -v -C out
ninja: Entering directory `out'
[0/1] ../../../gn/out/gn --root=./.. -q --C --regeneration gen .
ninja: no work to do.
$
```

### Important Files

* .gn
	```
	# The location of the build configuration file.
    buildconfig = "//build/BUILDCONFIG.gn"
	```
	- This file identifies the top level of the gn/ninja build system
	- The contents of this file specifies the `build` dir containing the configs file.
		- Once `gn gen` is run:
		- build/toolchain/BUILD.gn
		- build/BUILD.gn
		- build/BUILDCONFIG.gn
* BUILD.gn

### Important Commands

* `gn clean out`
	- This cleans out the results of the ninja build. ie. *.o, *.a, *.so, etc.
	- It does not clean out/*.gn files.
* `gn ls <build_dir> <target_wildcard>`
	- Lists all the targets
	- `gn ls out/ "//*"`
		* `//:main`
		* `//:mymath`
		* `//:mystring`
* `gn desc <build_dir> <target_name>`
	- Describes target for example provides
		* sources
		* Type of target. eg. executable, shared library or static library.
		* direct dependencies
	- `gn desc out/ "//:main"`
* `gn desc <build_dir> <target_name> deps --tree`
	- `gn desc out //:main deps --tree`
    - lists depends tree
	- `gn desc out/ "//:main"` deps --tree
* `gn args out`
    - opens an editor to override the default
* `gn args --list out`
    - shows all the args, default values and their documentation
* `gn analyze <out_dir> <input_path> <output_path>`
	- analyze which targets are affected by a list of files
	- If the input/output paths are `-`, then it
	uses stdin/stdout.
	- While helpfull, this is a bit tricky to use.
	- Here is a sample in.json
	```
	{
		"files":[
			"//src/xmain.cc",
			"//src/xMyString.cc",
			"//src/xMyMath.cc"
		],
		"test_targets":[
			"//:mystring"
		]
	}
	```
	- In this case, I want to find if the specified files are required to build the `mystring` library.  Since these are typos of the various
	source files, the analyze will say there is no dependency.
	```
	$ gn analyze out in.json  -
	{"compile_targets":[],"status":"No dependency","test_targets":[]}
	```
	- If the sample json file is corrected to have
	the proper filenames, then the output is:
	```
	$ gn analyze out in.json  -
	{"compile_targets":[],"status":"Found dependency","test_targets":["//:mystring"]}
	```
* `gn outputs <out_dir> <list of target or file names>`
	- 


### Important Target Declarations

These are common declarations used in `BUILD.gn`

* executable
	- Declare an executable target
	- Tools and commands used to create this target are determined by the source files in its sources.
	- C/C++ are allowed, but C and Rust are not.
* shared_library
	- Declare a shared library target
	- makes a `.so` file.
	- A shared library will be specified on the linker line for targets listing the shared library in it its "deps".
	- On osx use "loadable_module" instead.
* static_library
	- Declare a static library target
	- makes a `.a` or a `.lib` file.
	- If you want to skip the `.a`, but want intermediate results consider a `source set` instead.
* group
	- Declare a named group of targets
	- This target type creates meta-targets that just collect a set of dependencies into one named target.  
	- Groups can additionally specify configs that apply to their dependents.
	- Example
	```
	group("all") {
		deps = [
		"//project:runner",
		"//project:unit_tests",
		]   
  	}
	```
* loadable_module
	- Declare a loadable module target
	- Creates an object file that is (and can only be) loaded and unloaded at runtime.
	- If you don't want this (if you don't need to dynamically load the library at runtime), then you should use a "shared_library" target type instead.  (What?)
	- The style guide has more info on this relative to plaforms linux, windows and osx.  See [here](https://gn.googlesource.com/gn/+/main/docs/style_guide.md#loadable-modules-versus-shared-libraries)
* target
	- Declare a target with specified programmatic type
	- The target() function is a way to invoke a built-in target or template with a type determined at runtime.  This is useful for cases where the type of a target type might not be known statically.
	- Only templates and built-in target functions are supported for the target type string parameter.  Arbitrary functions, configs and toolchains are not supported.
	- signature:
	```
	target(target_type string, target_name string) { ... }
	```
	- Equvalent Example
	```
	target("source_set", "doom_melon") {...}
	```
	=
	```
	source_set("doom_melon") {...}
	```







